<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Dogeared Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guided introduction to bookmark merging with Dogear.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="integration.html"><strong aria-hidden="true">2.</strong> Integrating Dogear</a></li><li><ol class="section"><li><a href="trees.html"><strong aria-hidden="true">2.1.</strong> Fetching local and remote trees</a></li><li><a href="divergences.html"><strong aria-hidden="true">2.2.</strong> Divergences</a></li><li><a href="matching.html"><strong aria-hidden="true">2.3.</strong> Content matching</a></li><li><a href="application.html"><strong aria-hidden="true">2.4.</strong> Application</a></li></ol></li><li><a href="merging.html"><strong aria-hidden="true">3.</strong> The merge algorithm</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Dogeared Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#what-is-dogear" id="what-is-dogear"><h1>What is Dogear?</h1></a>
<p>Dogear is a library that implements bookmark tree merging for <a href="https://mozilla.github.io/application-services/docs/sync/welcome.html">Firefox Sync</a>. It takes two trees‚Äîa valid, consistent local tree, and a possibly inconsistent remote tree‚Äîand produces a complete merged tree, with all conflicts and inconsistencies resolved.</p>
<p>Dogear implements the merge algorithm only; it doesn't handle syncing, storage, or application on its own. It's up to your crate to:</p>
<ul>
<li>Persist local and remote bookmarks in a database.</li>
<li>Build trees from those bookmarks.</li>
<li>Update the local and remote trees to match the merged tree, and...</li>
<li>Upload records for changed bookmarks.</li>
</ul>
<a class="header" href="#bookmark-syncing" id="bookmark-syncing"><h2>Bookmark syncing</h2></a>
<p>Bookmarks are <a href="https://blog.nightly.mozilla.org/2018/05/14/deep-dive-new-bookmark-sync-in-nightly/">one of the more complicated data types</a> to sync. Locally, they form a hierarchy, where each bookmark lives in exactly one folder, and has a unique position within that folder.</p>
<p>On the server, the hierarchy is flattened into a collection of unordered, encrypted records. Folders keep pointers to their children, and children back to their parents. This means that some changes, like moving a bookmark or deleting a folder, need to upload multiple records in lockstep.</p>
<a class="header" href="#conflict-resolution" id="conflict-resolution"><h2>Conflict resolution</h2></a>
<p>Clients must also handle merge conflicts. Most are easy to resolve, like adding a bookmark to a folder on one side, or even adding bookmarks to the same folder on different devices. Ditto for deletions and moves.</p>
<p>Conflicts where a bookmark is deleted on one side and changed on the other, or where a folder is deleted on one side and has new children on the other, are harder. When resolving conflicts, it's important to flag all affected records for upload, so that the remote tree remains consistent.</p>
<p>Dogear manages this complexity, so that clients don't have to implement their own merging logic.</p>
<a class="header" href="#integrating-dogear" id="integrating-dogear"><h1>Integrating Dogear</h1></a>
<p>The cornerstone of Dogear is the <code>Store</code> trait. A <code>Store</code> implements methods for:</p>
<ul>
<li>Building local and remote trees.</li>
<li>Fetching content info for matching bookmarks with similar contents.</li>
<li>Applying the merged tree.</li>
</ul>
<p>Exactly how this is done is up to your crate!</p>
<p>For example, Firefox Desktop stores local bookmarks in an <a href="https://sqlite.org/index.html">SQLite</a> database called <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Database">Places</a>, and remote bookmarks in an attached <a href="https://searchfox.org/mozilla-central/rev/7abb9117c8500ed20833746c9f8e800fce3a4688/toolkit/components/places/SyncedBookmarksMirror.jsm">&quot;mirror&quot;</a> database. During application, Desktop inserts the merged tree into a temporary, in-memory table, then uses triggers to update Places and stage outgoing items for upload.</p>
<p>The Rust Places library is similar to Desktop, but stores local and remote bookmarks in the same database.</p>
<p>However, <em>nothing in Dogear is SQLite-specific</em>. You can use a key-value store like <a href="https://docs.rs/rkv/0.9.4/rkv/">LMDB</a>, or even a JSON file. Also, while Dogear was developed specifically for Firefox Sync clients, you can use it to merge any two bookmark trees.</p>
<p>The second trait that you'll want to implement is <code>Driver</code>. The driver lets your crate customize merging behavior, including:</p>
<ul>
<li>Fixing up invalid item GUIDs.</li>
<li>Logging.</li>
</ul>
<p>Dogear includes a default driver that rejects invalid GUIDs, and calls the <code>log</code> crate's global logger. In Firefox Desktop, the merge driver posts log messages to the main thread, where they're sent to Sync's log manager. In Rust Places, the logger implementation sends logs to platform-specific logging backends on Android and iOS.</p>
<p>And that's it! Once you've implemented these two traits, you can use <code>Store::merge_with_driver</code> to run the merge and collect telemetry.</p>
<p>In the next section, we'll take a closer look at how to implement a <code>Store</code>.</p>
<a class="header" href="#fetching-local-and-remote-trees" id="fetching-local-and-remote-trees"><h1>Fetching local and remote trees</h1></a>
<p>First, we need to teach our <code>Store</code> to inflate trees from the storage backend. As you might expect, <code>fetch_local_tree</code> builds the local tree, and <code>fetch_remote_tree</code> builds the remote tree. The trees should be complete, so don't leave out orphans, missing children, or bookmarks with invalid GUIDs or URLs. That way, Dogear has a full picture of the state of the world.</p>
<p>Let's assume we've stored the following records. The current time is T = 11, A was downloaded during the last sync (at T = 6), and the menu and B during this sync:</p>
<pre><code class="language-json">{ &quot;id&quot;: &quot;menu&quot;, &quot;type&quot;: &quot;folder&quot;, &quot;parentid&quot;: &quot;places&quot;, &quot;children&quot;: [&quot;bookmarkAAAA&quot;, &quot;bookmarkBBBB&quot;], &quot;modified&quot;: 10 }
{ &quot;id&quot;: &quot;bookmarkAAAA&quot;, &quot;type&quot;: &quot;bookmark&quot;, &quot;parentid&quot;: &quot;menu&quot;, &quot;modified&quot;: 5 }
{ &quot;id&quot;: &quot;bookmarkBBBB&quot;, &quot;type&quot;: &quot;bookmark&quot;, &quot;parentid&quot;: &quot;menu&quot;, &quot;modified&quot;: 10 }
</code></pre>
<p>We can build a tree from those records like this, starting with the root:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# extern crate dogear;
use dogear::{Item, Tree};
let mut builder = Tree::with_root(Item::root());
#}</code></pre></pre>
<p>For cases where we know the structure is valid, and the tree already contains the parent, we can use <code>by_structure</code> to indicate that the parent's <code>children</code> and child's <code>parentid</code> match. This is how we build the local tree on Desktop. Notice that we also set the <code>needs_merge</code> flag, to indicate that the menu has changes that we should merge:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate dogear;
# use dogear::{Result, Tree};
use dogear::{Guid, Item, Kind, MENU_GUID, ROOT_GUID};

# fn main() -&gt; Result&lt;()&gt; {
let now_millis = 11;

# let mut builder = Tree::with_root(Item::root());
let mut menu = Item::new(MENU_GUID.clone(), Kind::Folder);
menu.age = now_millis - 10;
menu.needs_merge = true;

builder
    .item(menu)?
    .by_structure(&amp;ROOT_GUID)?;
# Ok(())
# }
</code></pre></pre>
<p>For cases where the <code>parentid</code> and <code>children</code> might disagree, we can set parents from <code>parentid</code> and <code>children</code> separately, using <code>by_parent_guid</code> and <code>by_children</code>. This is equivalent to <code>by_structure</code>, just slightly less efficient:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate dogear;
# use dogear::{Item, Kind, Tree, Result, MENU_GUID, ROOT_GUID};
# fn main() -&gt; Result&lt;()&gt; {
# let now_millis = 11;
# let mut builder = Tree::with_root(Item::root());
# let mut menu = Item::new(MENU_GUID.clone(), Kind::Folder);
# builder.item(menu)?.by_structure(&amp;ROOT_GUID)?;
let mut a = Item::new(&quot;bookmarkAAAA&quot;.into(), Kind::Bookmark);
a.age = now_millis - 5;

builder
    .item(a)?
    .by_parent_guid(MENU_GUID.clone())?;
builder.parent_for(&amp;&quot;bookmarkAAAA&quot;.into())
    .by_children(&amp;MENU_GUID)?;
# Ok(())
# }
</code></pre></pre>
<p>We can also insert an item without its parents, and set parents by <code>parentid</code> and <code>children</code> later, if they exist. This is also equivalent to the above:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate dogear;
# use dogear::{Item, Kind, Tree, Result, MENU_GUID, ROOT_GUID};
# fn main() -&gt; Result&lt;()&gt; {
# let now_millis = 11;
# let mut builder = Tree::with_root(Item::root());
# let mut menu = Item::new(MENU_GUID.clone(), Kind::Folder);
# builder.item(menu)?.by_structure(&amp;ROOT_GUID)?;
let mut b = Item::new(&quot;bookmarkBBBB&quot;.into(), Kind::Bookmark);
b.age = now_millis - 10;
b.needs_merge = true;

builder.item(b)?;
builder.parent_for(&amp;&quot;bookmarkBBBB&quot;.into())
    .by_parent_guid(MENU_GUID.clone())?;
builder.parent_for(&amp;&quot;bookmarkBBBB&quot;.into())
    .by_children(&amp;MENU_GUID)?;
# Ok(())
# }
</code></pre></pre>
<p>Finally, let's build and print out our tree!</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate dogear;
# use dogear::{Item, Tree, Result};
use dogear::IntoTree;
# fn main() -&gt; Result&lt;()&gt; {
# let mut builder = Tree::with_root(Item::root());
let tree = builder.into_tree()?;
println!(&quot;{}&quot;, tree);
# Ok(())
# }
</code></pre></pre>
<p>And we see:</p>
<pre><code class="language-txt">üìÇ root________ (Folder; Age = 0ms)
| üìÇ menu________ (Folder; Age = 1ms; Unmerged)
| | üîñ bookmarkAAAA (Bookmark; Age = 6ms)
| | üîñ bookmarkBBBB (Bookmark; Age = 1ms; Unmerged)
</code></pre>
<a class="header" href="#divergences" id="divergences"><h1>Divergences</h1></a>
<p>In the last section, the tree is totally consistent. Let's look at a case where we're not so lucky:</p>
<pre><code class="language-json">{ &quot;id&quot;: &quot;menu&quot;, &quot;type&quot;: &quot;folder&quot;, &quot;parentid&quot;: &quot;places&quot;, &quot;children&quot;: [&quot;bookmarkAAAA&quot;], &quot;modified&quot;: 5 }
{ &quot;id&quot;: &quot;toolbar&quot;, &quot;type&quot;: &quot;folder&quot;, &quot;parentid&quot;: &quot;places&quot;, &quot;children&quot;: [&quot;bookmarkBBBB&quot;, &quot;bookmarkAAAA&quot;], &quot;modified&quot;: 10 }
{ &quot;id&quot;: &quot;unfiled&quot;, &quot;type&quot;: &quot;folder&quot;, &quot;parentid&quot;: &quot;places&quot;, &quot;children&quot;: [&quot;bookmarkEEEE&quot;], &quot;modified&quot;: 5 }
{ &quot;id&quot;: &quot;bookmarkAAAA&quot;, &quot;type&quot;: &quot;bookmark&quot;, &quot;parentid&quot;: &quot;folderCCCCCC&quot;, &quot;modified&quot;: 5 }
{ &quot;id&quot;: &quot;bookmarkDDDD&quot;, &quot;type&quot;: &quot;bookmark&quot;, &quot;parentid&quot;: &quot;menu&quot;, &quot;modified&quot;: 5 }
{ &quot;id&quot;: &quot;bookmarkEEEE&quot;, &quot;type&quot;: &quot;bookmark&quot;, &quot;parentid&quot;: &quot;unfiled&quot;, &quot;modified&quot;: 10 }
</code></pre>
<p>What's going on here?</p>
<ul>
<li>Both the menu and toolbar claim A as a child, but A says its <code>parentid</code> is C, which doesn't exist.</li>
<li>The toolbar references B in its <code>children</code>, but B is nowhere to be found. B is a missing child.</li>
<li>D says its <code>parentid</code> is the menu‚Äîwhich exists‚Äîbut the menu doesn't mention D in its children.</li>
<li>E is the only bookmark where its <code>parentid</code> matches its parent's <code>children</code>.</li>
</ul>
<p>Yikes!</p>
<p>Remember that, while we can enforce hierarchical invariants for the local tree, we can't guarantee anything about the remote tree. This is because the Firefox Sync storage server can't see the contents of bookmarks, and must rely on clients alone to upload consistent data.</p>
<p>Unfortunately, bugs and missing features in older clients caused them to miss changes, or not upload records at all. This leads to the <em>structure divergences</em> that we see here, like orphans, missing children, and parent-child disagreements. Newer Desktops shouldn't upload inconsistencies, but other platforms can, and many long-time Sync users have existing inconsistencies that confuse new clients when they sync for the first time.</p>
<p>Let's add this tree to Dogear:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate dogear;
use dogear::{Guid, IntoTree, Item, Kind, Tree, MENU_GUID, ROOT_GUID, TOOLBAR_GUID, UNFILED_GUID};
# use dogear::Result;
# fn main() -&gt; Result&lt;()&gt; {
let now_millis = 11;

let mut builder = Tree::with_root(Item::root());

let mut menu = Item::new(MENU_GUID.clone(), Kind::Folder);
menu.age = now_millis - 5;
menu.needs_merge = true;
builder
    .item(menu)?
    .by_structure(&amp;ROOT_GUID)?;

let mut toolbar = Item::new(TOOLBAR_GUID.clone(), Kind::Folder);
toolbar.age = 0;
toolbar.needs_merge = true;
builder
    .item(toolbar)?
    .by_structure(&amp;ROOT_GUID)?;

let mut unfiled = Item::new(UNFILED_GUID.clone(), Kind::Folder);
unfiled.age = now_millis - 5;
unfiled.needs_merge = true;
builder
    .item(unfiled)?
    .by_structure(&amp;ROOT_GUID)?;

let mut a = Item::new(&quot;bookmarkAAAA&quot;.into(), Kind::Bookmark);
a.age = now_millis - 5;
builder.item(a)?;

let mut d = Item::new(&quot;bookmarkDDDD&quot;.into(), Kind::Bookmark);
d.age = now_millis - 5;
builder.item(d)?;

let mut e = Item::new(&quot;bookmarkEEEE&quot;.into(), Kind::Bookmark);
e.age = 0;
builder.item(e)?;

// A is mentioned in both the menu's and toolbar's `children`, and its
// `parentid` is C.
builder.parent_for(&amp;&quot;bookmarkAAAA&quot;.into())
    .by_children(&amp;MENU_GUID)?
    .parent_for(&amp;&quot;bookmarkAAAA&quot;.into())
    .by_children(&amp;TOOLBAR_GUID)?
    .parent_for(&amp;&quot;bookmarkAAAA&quot;.into())
    .by_parent_guid(&quot;folderCCCCCC&quot;.into())?;

// B is mentioned in the toolbar's `children`.
builder.parent_for(&amp;&quot;bookmarkBBBB&quot;.into())
    .by_children(&amp;TOOLBAR_GUID)?;

// D's `parentid` is the menu, even though it's not mentioned in the menu's
// `children`.
builder.parent_for(&amp;&quot;bookmarkDDDD&quot;.into())
    .by_parent_guid(MENU_GUID.clone())?;

// E's `parentid` is unfiled, and unfiled's `children` mention E.
builder.parent_for(&amp;&quot;bookmarkEEEE&quot;.into())
    .by_structure(&amp;UNFILED_GUID)?;

let tree = builder.into_tree()?;
println!(&quot;{}&quot;, tree);
# Ok(())
# }
</code></pre></pre>
<p>When we print this tree, we see:</p>
<pre><code class="language-txt">üìÇ root________ (Folder; Age = 0ms)
| üìÇ menu________ (Folder; Age = 6ms; Unmerged)
| | ‚ùóÔ∏èüîñ bookmarkDDDD (Bookmark; Age = 6ms)
| üìÇ toolbar_____ (Folder; Age = 0ms; Unmerged)
| | ‚ùóÔ∏èüîñ bookmarkAAAA (Bookmark; Age = 6ms)
| üìÇ unfiled_____ (Folder; Age = 6ms; Unmerged)
| | üîñ bookmarkEEEE (Bookmark; Age = 0ms)
</code></pre>
<p>When Dogear built this tree, it saw inconsistencies, and decided where to keep each item based on its age. It also marked the tree structure as diverged, indicated with a ‚ùóÔ∏è, so that the merger can flag it for reupload.</p>
<a class="header" href="#content-matching" id="content-matching"><h1>Content matching</h1></a>
<p><code>Store::fetch_new_local_contents</code> and <code>Store::fetch_new_remote_contents</code> provide information that the merger uses to <strong>dedupe</strong> new local items to incoming remote items with different GUIDs and similar contents. They return <code>HashMap</code>s that map a candidate item's GUID to its content info.</p>
<p>Two items are a match if they have congruent parents and matching properties:</p>
<ul>
<li>Bookmarks and queries match if they have the same title and URL.</li>
<li>Folders match if they have the same title.</li>
<li>Separators match if they have the same position in their respective parents.</li>
</ul>
<p>Here are three suggestions for implementing <code>fetch_new_local_contents</code> and <code>fetch_new_remote_contents</code>:</p>
<ul>
<li>Neither should return roots.</li>
<li><code>fetch_new_local_contents</code> should only return local items that haven't been uploaded before. In Firefox Desktop and Rust Places, these are all items with a <code>NEW</code> or <code>UNKNOWN</code> sync status.</li>
<li><code>fetch_new_remote_contents</code> should only return remote items that have changed since the last sync, and don't exist locally. In Desktop and Rust Places, these are items with <code>needsMerge</code> set.</li>
</ul>
<p>The merger still does the right thing if you don't follow these suggestions, but, depending on your storage backend, it may be more efficient if you do.</p>
<p>For example, you can return content info for all items in your store, if you want! This makes sense if all the content info is in memory already, or where filtering contents is more costly. On the other hand, if you're using a store like SQLite, it's more efficient to filter out contents that you know won't match in the query.</p>
<p>You can disable deduping entirely by returning empty <code>HashMap</code>s from these methods.</p>
<a class="header" href="#application" id="application"><h1>Application</h1></a>
<p>The last method that we need to implement is <code>Store::apply</code>. This method takes a merged root and a set of deletions, and updates the local tree to match the merged tree.</p>
<a class="header" href="#merging" id="merging"><h1>Merging</h1></a>
<p>Dogear's <code>Merger</code> produces a complete, consistent merged tree from a local and remote bookmark tree. The merge algorithm examines each item, and resolves two kinds of changes:</p>
<ul>
<li><strong>Structure changes</strong> to an item's parent or children, like adding or deleting an item, moving an item to a different folder, or reordering a folder's children.</li>
<li><strong>Value changes</strong> to an item's properties, like the title or URL.</li>
</ul>
<a class="header" href="#merge-states" id="merge-states"><h2>Merge states</h2></a>
<p>Each merged item has a merge state that describes how to resolve the change. The merge state determines:</p>
<ul>
<li>Which side‚Äîlocal or remote‚Äîto prefer when resolving a conflict.</li>
<li>Whether or not to <strong>apply</strong> a remote change to the local tree.</li>
<li>Whether or not to <strong>upload</strong> the merged item to the server.</li>
</ul>
<p>There are seven merge states:</p>
<ul>
<li>Items that are unchanged (<code>MergeState::Unchanged</code>) on both sides don't need to be uploaded or applied.</li>
<li>Items that only exist remotely (<code>MergeState::RemoteOnly</code>), only changed remotely, or have newer remote changes (<code>MergeState::Remote</code>), must be applied to the local tree. This overwrites any local changes to the item.</li>
<li>Items that only exist remotely (<code>MergeState::RemoteOnlyWithNewStructure</code>) or have newer remote changes (<code>MergeState::RemoteWithNewStructure</code>), but <em>conflict</em> with local structure changes, must be applied to the local tree <em>and</em> reuploaded to the server. This resolves the conflict on both sides.</li>
<li>Items that only exist locally (<code>MergeState::LocalOnly</code>), only changed locally, or have newer local changes (<code>MergeState::Local</code>), must be uploaded to the server. This overwrites remote changes to the item. Since <code>LocalOnly</code> and <code>Local</code> always imply upload, there are no corresponding <code>WithNewStructure</code> states.</li>
</ul>
<p>The merger starts at the roots of both trees, and recursively walks their children, eventually visiting every item.</p>
<a class="header" href="#conflicts" id="conflicts"><h2>Conflicts</h2></a>
<p>Structure and value conflicts, where an item changes on both sides, are resolved using timestamps, picking the chronologically newer side. The merger handles conflicts at the <em>item</em> level, not the <em>property</em> level, using the <code>needs_merge</code> flag.</p>
<p>For example, consider changing a bookmark's title locally, and the same bookmark's URL remotely. Both items have <code>needs_merge = true</code> set.</p>
<ul>
<li>If the local title change is newer (<code>local_item.age &lt; remote_item.age</code>), the URL change will be reverted on the server.</li>
<li>If the remote URL change is newer (<code>remote_item.age &gt; local_item.age</code>), the title change will be reverted locally.</li>
</ul>
<p>Since the only indication that an item changed is its <code>needs_merge</code> flag, and there's no shared parent tree, Dogear can't know which fields changed, or if they're independent. In other words, the merger knows <em>that</em> the item changed, but not <em>how</em>. For this reason, the algorithm is a <strong>two-way merge</strong>, not a three-way merge.</p>
<p>This is a trade-off between simplicity and correctness: it removes a chunk of complexity from Dogear, and means that clients don't need to persist snapshots of the shared tree. However, it does mean that some conflicts will cause changes to revert on one side, which is a form of data loss.</p>
<a class="header" href="#deletions" id="deletions"><h2>Deletions</h2></a>
<p>Conflicts where an item is deleted on one or both sides are handled specially:</p>
<ul>
<li>If a non-folder item is changed on one side and deleted on the other, we ignore the deletion, and <em>revive</em> the item.</li>
<li>If a non-root folder is changed on one side and deleted on the other, we keep the folder deleted, and recursively move any new descendants that don't exist on the other side to the closest surviving parent folder.</li>
<li>If a root folder is deleted on one side, we ignore the deletion and revive the root. This should never happen except in cases of corruption on the server.</li>
</ul>
<p>If an item is deleted on both sides, there's no conflict, so we keep the deletion.</p>
<a class="header" href="#non-syncable-items" id="non-syncable-items"><h2>Non-syncable items</h2></a>
<p>A non-syncable item is:</p>
<ul>
<li>Any item that's not a descendant of a <em>user content root</em> (menu, mobile, toolbar, or unfiled) on either side.</li>
<li>A remote livemarks.</li>
<li>A remote orphaned query.</li>
</ul>
<p>If an item isn't syncable on either side‚Äîfor example, a legacy organizer left pane query might be non-syncable locally, but orphaned and syncable remotely‚Äîit's deleted. Any syncable descendants of a non-syncable folder are relocated to the closest surviving parent folder.</p>
<a class="header" href="#deduping" id="deduping"><h2>Deduping</h2></a>
<p>If a remote item with the same GUID doesn't exist locally, the merger first tries to find an item with similar contents. This is called deduping. An item is a candidate for deduping if:</p>
<ul>
<li>It's not a root.</li>
<li>It hasn't synced before. As a consequence, items that are already on the server will never dedupe to one another, even if they match.</li>
</ul>
<a class="header" href="#invalid-items" id="invalid-items"><h2>Invalid items</h2></a>
<p>If an item on either side has an invalid GUID, the merger asks the <code>Driver</code> to generate a new one.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
